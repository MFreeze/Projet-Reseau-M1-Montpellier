\documentclass[a4paper]{article}
\usepackage[francais]{babel}
\usepackage[T1]{fontenc}
\usepackage[applemac]{inputenc}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage[colorlinks=true]{hyperref}
\hypersetup{urlcolor=blue,linkcolor=black,colorlinks=true} 
\usepackage{algorithm,algorithmic}
\usepackage{listings}
\usepackage{amssymb}
\usepackage{setspace}
\usepackage{listings}
\usepackage{lscape}

\pagestyle{headings}
\thispagestyle{empty}
\geometry{a4paper,twoside,left=2.5cm,right=2.5cm,marginparwidth=1.2cm,marginparsep=3mm,top=2.5cm,bottom=2.5cm}
\begin{document}
\large
\setlength{\parindent}{ 0 pt}
\lstset{language=C, showstringspaces=false, numbers=left, numberstyle=\tiny, tabsize=4}
\setlength{\parskip}{5mm plus2mm minus2mm}
Chloé DESDOUITS \hfill M1 Informatique MOCA\\
Guillerme DUVILLIE
\vfill
{\centering \Huge \bfseries Projet de réseau \par}
\vfill
23 décembre 2011 \hfill UM2
\newpage

\setlength{\parindent}{1 cm}
\pagenumbering{arabic}

~\\

\section{Mode d'emploi}\label{manuel}
Tout d'abord, notre application nécessite l'installation de la bibliothèque \href{http://ftp.gnu.org/pub/gnu/ncurses/}{Ncurses} qui gère l'interface console. Il suffit ensuite de compiler grâce au Makefile.

L'exécutable du serveur se nomme "serveur" et accepte les paramètres suivants :

\begin{itemize}
\item -n nom de l'hote (par default 'localhost')
\item -a adresse ip de l'hote (par default '127.0.0.1')
\item -p numero de port qu'utilisera le serveur d'envoi (par default '13321')
\item -ps numero de port secondaire qu'utilisera le serveur de réception (par default '13322')
\item -h ou - -help affichage de l'aide
\end{itemize}


L'exécutable du client se nomme "client" et accepte les paramètres suivants :

\begin{itemize}
\item -n nom de l'hote (par default 'localhost')
\item -N nom de l'hote du serveur (par default 'localhost')
\item -a adresse ip de l'hote (par default '127.0.0.1')
\item -A adresse ip du serveur (par default '127.0.0.1')
\item -P numero de port qu'utilise le serveur d'envoi (par default '13321')
\item -S numero de port qu'utilise le serveur de réception (par default '13322')
\item -h affichage de l'aide
\end{itemize}

Par conséquent, pour lancer l'application en local, il suffit d'appeler les exécutables du serveur et du client sans paramètres. Voici un exemple de ligne de commande pour lancer l'application en réseau :\\
\$ serveur -a 192.168.1.131\\
\$ client -a 192.168.1.96 -A 192.168.1.13

Une fois le client lancé, la demande de contrôle de la caméra s'effectue en pressant la touche 'c'. On peut relâcher le contrôle prématurément en appuyant sur 'q'. La direction est donnée à la caméra grâce aux touches directionnelles.

Les exécutables se quittent en envoyant le signal SIGINT (ctrl-c).


\section{Architecture de l'application}\label{archi}
Commençons par examiner l'architecture du serveur. Notre serveur est divisé en deux processus, les deux étant multi-thread.

Le processus père est le serveur d'envoi ; il gère le broadcast de la grille. Son thread principal accepte les connexions des clients et crée un thread secondaire par client connecté. Les threads secondaires envoient la grille à leur client respectif.

Le processus fils est le serveur de réception ; il traite les demandes de déplacement de la caméra. Son thread principal gère la file d'attente des clients qui veulent déplacer la caméra. Il lance un thread secondaire pour le premier client qui demande la main. Ce thread secondaire gère le déplacement du pointeur dans la grille. Le thread principal tue le thread secondaire à la fin du temps imparti et relance un thread secondaire pour le client suivant.\\


Le client, quant à lui, est également multi-threads. Son thread principal gère la réception et l'affichage de la grille. Tandis que son thread secondaire gère les entrées clavier et envoi les demandes de contrôle de la caméra au serveur de réception.

\begin{figure}[h]
\begin{center}
\includegraphics[scale=1]{schema_global.png}
\end{center}
\caption{Schéma global décrivant l'architecture de l'application}
\end{figure}

\section{Protocoles d'échange}\label{protocoles}

\subsection{Echanges entre le serveur d'envoi d'images et la partie affichage du client}

Le protocole est très simple puisqu'il est à sens unique : on procède simplement à une création de
sockets et une demande de connexion côté client. Du côté serveur, il y a acceptation de la
connexion, création du thread et envoi de données. La figure \ref{fig1} (p.\pageref{fig1}) en est
une schématisation possible.

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.7]{fig1.png}
\end{center}
\caption{Protocole d'échange entre le serveur d'émission d'images et le client}
\label{fig1}
\end{figure}

\subsection{Echanges entre le serveur de contrôle de la caméra et le client}

Le protocole est un petit peu plus compliqué, en effet une fois la connexion au serveur de contrôle
de caméra demandée, celle ci est automatiquement acceptée si le nombre de clients déjà connectés est
inférieur à une constante (20 en l'occurrence). Les sockets correspondant aux clients sont sauvegardées dans une file
d'attente qui permet de savoir en temps réel le nombre de clients en attente du contrôle de la
caméra\footnote{Ce nombre permet de calculer le temps maximum de contrôle de la caméra pour le
client en cours d'utilisation}. Une fois le contrôle libre, le serveur prend la première socket de
la file et crée un thread qui prend en charge le client. Pour garder le client en attente, une fois
la connexion effectuée celui ci attends un message de la part du serveur lui servant d'\emph{accusé
de prise en charge}. Les échanges ayant lieu ensuite sont à sens unique du client détenant le
contrôle vers le thread de gestion des clients du serveur de contrôle. La libération du contrôle de la
caméra est représentée par une mise à zéro de la variable globale \verb?cam_moving?, le client quant
à lui est mis au courant de la fin de sa session par fermeture de sa socket du coté serveur.

La figure \ref{fig2} (p. \pageref{fig2}) est une schématisation possible de l'échange.

\textbf{\underline{Remarque} :} Si la liste est pleine, le client est refusé à la demande de
connexion à l'aide de \verb?listen? dont la liste d'attente a été initialisée à 1.

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.6]{fig2.png}
\end{center}
\caption{Protocole d'échange entre le serveur de controle de la caméra et le client}
\label{fig2}
\end{figure}

\subsection{Echanges entre les deux composantes du serveur}

Les échanges entre les deux parties du serveurs sont très limités, ils se résument à un segment de
mémoire partagée contenant la grille et à l'échange de signaux en cas d'interruption du serveur. 
Par soucis de rapidité (surtout avec un grand nombre de client), les accès à la grille ne sont pas
protégés puisque le thread de gestion de client du serveur de contrôle est le seul à y accéder en
écriture, le sémaphore est donc superflu.

\section{Schémas algorithmiques}\label{algo}
Voici les schémas algorithmiques des différentes composantes de notre application.

\begin{figure}[H]
\begin{center}
\includegraphics[scale=0.7]{client_prin.png}
\end{center}
\caption{Thread principal du client}
\end{figure}

\begin{figure}[H]
\begin{center}
\includegraphics[scale=0.7]{thead_client.png}
\end{center}
\caption{Thread de contrôle de caméra du client}
\end{figure}

\begin{figure}[H]
\begin{center}
\includegraphics[scale=0.7]{serv2_thr1.png}
\end{center}
\caption{Thread principal du serveur de contrôle de la caméra}
\end{figure}

\begin{figure}[H]
\begin{center}
\includegraphics[scale=0.7]{serv2_thr2.png}
\end{center}
\caption{Thread secondaire du serveur de contrôle de la caméra}
\end{figure}

\begin{figure}[H]
\begin{center}
\includegraphics[scale=0.7]{serv1_thr1.png}
\end{center}
\caption{Thread principal du serveur d'envoi d'images}
\end{figure}

\begin{figure}[H]
\begin{center}
\includegraphics[scale=0.7]{serv2_thr2.png}
\end{center}
\caption{Thread subsidiaire de gestion d'un client du serveur d'envoi d'images}
\end{figure}

\section{Difficultés et solutions}\label{difficultes}
Nous avons été confrontés à quelques problèmes lors de la mise en œuvre de notre application. Les principaux sont détaillés ci-dessous.

Lorsqu'un thread secondaire utilise les appels systèmes recv ou send en mode connecté alors que la socket a été fermée de l'autre côté, un signal SIGPIPE est émis. Ce signal doit être intercepté par le thread principal sous peine de terminer l'application.

L'interface console Ncurses supporte normalement le redimensionnement de la fenêtre de terminal. Cependant, nous n'avons pas trouvé le temps nécessaire pour prendre en charge le redimensionnement de la fenêtre dans laquelle est lancé le client.

\vfill
{\raggedleft Réalisé avec \LaTeX{} \par}

\end{document}
