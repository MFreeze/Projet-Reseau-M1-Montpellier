\documentclass[a4paper]{article}
\usepackage[francais]{babel}
\usepackage[T1]{fontenc}
\usepackage[applemac]{inputenc}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage[colorlinks=true]{hyperref}
\hypersetup{urlcolor=blue,linkcolor=black,colorlinks=true} 
\usepackage{algorithm,algorithmic}
\usepackage{listings}
\usepackage{amssymb}
\usepackage{setspace}
\usepackage{listings}
\usepackage{lscape}

\pagestyle{headings}
\thispagestyle{empty}
\geometry{a4paper,twoside,left=2.5cm,right=2.5cm,marginparwidth=1.2cm,marginparsep=3mm,top=2.5cm,bottom=2.5cm}
\begin{document}
\large
\setlength{\parindent}{ 0 pt}
\lstset{language=C, showstringspaces=false, numbers=left, numberstyle=\tiny, tabsize=4}
\setlength{\parskip}{5mm plus2mm minus2mm}
Chlo DESDOUITS \hfill M1 Informatique MOCA\\
Guillerme DUVILLIE
\vfill
{\centering \Huge \bfseries Projet de rseau \par}
\vfill
23 dcembre 2011 \hfill UM2

\newpage
\tableofcontents
\thispagestyle{empty}

\setlength{\parindent}{1 cm}
\pagenumbering{arabic}

~\\

\section{Mode d'emploi}\label{manuel}
Tout d'abord, notre application ncessite l'installation de la bibliothque \href{http://ftp.gnu.org/pub/gnu/ncurses/}{Ncurses} qui gre l'interface console. Il suffit ensuite de compiler gr‰ce au Makefile.

L'excutable du serveur se nomme "serveur" et accepte les paramtres suivants :

\begin{itemize}
\item -n nom de l'hote (par default 'localhost')
\item -a adresse ip de l'hote (par default '127.0.0.1')
\item -p numero de port qu'utilisera le serveur d'envoi (par default '13321')
\item -ps numero de port secondaire qu'utilisera le serveur de rception (par default '13322')
\item -h ou - -help affichage de l'aide
\end{itemize}


L'excutable du client se nomme "client" et accepte les paramtres suivants :

\begin{itemize}
\item -n nom de l'hote (par default 'localhost')
\item -N nom de l'hote du serveur (par default 'localhost')
\item -a adresse ip de l'hote (par default '127.0.0.1')
\item -A adresse ip du serveur (par default '127.0.0.1')
\item -P numero de port qu'utilise le serveur d'envoi (par default '13321')
\item -S numero de port qu'utilise le serveur de rception (par default '13322')
\item -h affichage de l'aide
\end{itemize}

Par consquent, pour lancer l'application en local, il suffit d'appeler les excutables du serveur et du client sans paramtres. Voici un exemple de ligne de commande pour lancer l'application en rseau :\\
\$ serveur -a 192.168.1.131\\
\$ client -a 192.168.1.96 -A 192.168.1.13

Une fois le client lanc, la demande de contr™le de la camra s'effectue en pressant la touche 'c'. On peut rel‰cher le contr™le prmaturment en appuyant sur 'q'. La direction est donne ˆ la camra gr‰ce aux touches directionnelles.

Les excutables se quittent en envoyant le signal SIGINT (ctrl-c).


\section{Architecture de l'application}\label{archi}
Commenons par examiner l'architecture du serveur. Notre serveur est divis en deux processus, les deux tant multi-thread.

Le processus pre est le serveur d'envoi ; il gre le broadcast de la grille. Son thread principal accepte les connexions des clients et cre un thread secondaire par client connect. Les threads secondaires envoient la grille ˆ leur client respectif.

Le processus fils est le serveur de rception ; il traite les demandes de dplacement de la camra. Son thread principal gre la file d'attente des clients qui veulent dplacer la camra. Il lance un thread secondaire pour le premier client qui demande la main. Ce thread secondaire gre le dplacement du pointeur dans la grille. Le thread principal tue le thread secondaire ˆ la fin du temps imparti et relance un thread secondaire pour le client suivant.\\


Le client, quant ˆ lui, est galement multi-threads. Son thread principal gre la rception et l'affichage de la grille. Tandis que son thread secondaire gre les entres clavier et envoi les demandes de contr™le de la camra au serveur de rception.


\section{Protocoles d'change}\label{protocoles}

\subsection{Echanges entre le serveur d'envoi d'images et la partie affichage du client}

Le protocole est très simple puisqu'il est à sens unique : on procède simplement à une création de
sockets et une demande de connexion côté client. Du côté serveur, il y a acceptation de la
connexion, création du thread et envoi de données. La figure \ref{fig1} (p.\pageref{fig1}) en est
une schématisation possible.

\begin{figure}
\begin{center}
\includegraphics[scale=0.4]{fig1.png}
\end{center}
\caption{Protocole d'échange entre le serveur d'émission d'images et le client}
\label{fig1}
\end{figure}

\subsection{Echanges entre le serveur de contrôle de la caméra et le client}

Le protocole est un petit peu plus compliqué, en effet une fois la connexion au serveur de contrôle
de caméra demandée, celle ci est automatiquement acceptée si le nombre de clients déjà connectés est
inférieur à une constante. Les sockets correspondant au client sont sauvegardées dans une file
d'attente qui permet de savoir en temps réel le nombre de clients en attente du contrôle de la
caméra\footnote{Ce nombre permet de calculer le temps maximum de contrôle de la caméra pour le
client en cours d'utilisation}. Une fois le contrôle libre, le serveur prend la première socket de
la file et crée un thread qui prend en charge le client. Pour garder le client en attente, une fois
la connexion effectuée celui ci attends un message de la part du serveur lui servant d'\emph{accusé
de prise en charge}. Les échanges ayant lieu ensuite sont à sens uniques du client détenant le
contrôle et le thread de gestion des clients du serveur de contrôle. La libération du contrôle de la
caméra est représentée par une mise à zéro de la variable globale \verb?cam_moving?, le client quant
à lui est mis au courant de la fin de sa session par fermeture de sa socket du coté serveur.

La figure \ref{fig2} (p. \pageref{fig2}) est une schématisation possible de l'échange.

\textbf{\underline{Remarque} :} Si la liste est pleine, le client est refusé à la demande de
connexion à l'aide de \verb?accept? dont la liste d'attente a été initialisée à 1.

\begin{figure}
\begin{center}
\includegraphics[scale=0.4]{fig2.png}
\end{center}
\caption{Protocole d'échange entre le serveur de controle de la caméra et le client}
\label{fig2}
\end{figure}

\subsection{Echanges entre les deux composantes du serveur}

Les échanges entre les deux parties du serveurs sont très limités, ils se résument à un segment de
mémoire partagée contenant la grille et à l'échange de signaux en cas d'interruption du serveur. 
Par soucis de rapidité (surtour avec un grand nombre de client), les accès à la grille ne sont pas
protégés puisque le thread de gestion de client du serveur de contrôle est le seul à y accéder en
écriture, le sémaphore est donc superflu.

\section{Schmas algorithmiques}\label{algo}

\begin{figure}
\begin{center}
\includegraphics[scale=0.35]{client_prin.png}
\end{center}
\caption{Thread principal du client}
\end{figure}

\begin{figure}
\begin{center}
\includegraphics[scale=0.35]{thead_client.png}
\end{center}
\caption{Thread de contrôle de caméra du client}
\end{figure}

\begin{figure}
\begin{center}
\includegraphics[scale=0.35]{serv2_thr1.png}
\end{center}
\caption{Thread principal du serveur de contrôle de la caméra}
\end{figure}

\begin{figure}
\begin{center}
\includegraphics[scale=0.35]{serv2_thr2.png}
\end{center}
\caption{Thread secondaire du serveur de contrôle de la caméra}
\end{figure}

\begin{figure}
\begin{center}
\includegraphics[scale=0.35]{serv1_thr1.png}
\end{center}
\caption{Thread principal du serveur d'envoi d'images}
\end{figure}

\begin{figure}
\begin{center}
\includegraphics[scale=0.35]{serv2_thr2.png}
\end{center}
\caption{Thread subsidiaire de gestion d'un client du serveur d'envoi d'images}
\end{figure}

\section{Difficults et solutions}\label{difficultes}
Lorsqu'un thread secondaire utilise les appels systmes recv ou send en mode connect alors que la socket a t ferme de l'autre c™t, un signal SIGPIPE est mis. Ce signal doit tre intercept par le thread principal sous peine de terminer l'application.

\vfill
{\raggedleft Ralis avec \LaTeX{} \par}

\end{document}
